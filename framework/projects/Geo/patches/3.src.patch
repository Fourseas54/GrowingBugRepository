diff --git a/geo/src/main/java/com/github/davidmoten/geo/GeoHash.java b/geo/src/main/java/com/github/davidmoten/geo/GeoHash.java
index 40f2e4d..80bd3c6 100644
--- a/geo/src/main/java/com/github/davidmoten/geo/GeoHash.java
+++ b/geo/src/main/java/com/github/davidmoten/geo/GeoHash.java
@@ -637,38 +637,33 @@ public final class GeoHash {
             double bottomRightLat, double bottomRightLon, final int length) {
         Preconditions.checkArgument(topLeftLat >= bottomRightLat,
                 "topLeftLat must be >= bottomRighLat");
+        Preconditions.checkArgument(topLeftLon <= bottomRightLon,
+                "topLeftLon must be <= bottomRighLon");
         Preconditions.checkArgument(length > 0, "length must be greater than zero");
         final double actualWidthDegreesPerHash = widthDegrees(length);
         final double actualHeightDegreesPerHash = heightDegrees(length);
 
         LongSet hashes = new LongSet();
 
-        double diff = bottomRightLon - topLeftLon;
-        if (diff < 0) {
+        double diff = longitudeDiff(bottomRightLon, topLeftLon);
             // case where bottomRightLon cross the antimeridian
-            bottomRightLon += 360;
-            diff = bottomRightLon - topLeftLon;
-        } else if (diff > 360) {
+        double maxLon = topLeftLon + diff;
             // case where this bounding box displays more than one copy of the world
-            topLeftLon = -180;
-            bottomRightLon = 180;
-            diff = 360;
-        }
 
         for (double lat = bottomRightLat; lat <= topLeftLat; lat += actualHeightDegreesPerHash) {
-            for (double lon = topLeftLon; lon <= bottomRightLon; lon += actualWidthDegreesPerHash) {
-                hashes.add(encodeHashToLong(lat, to180(lon), length));
+            for (double lon = topLeftLon; lon <= maxLon; lon += actualWidthDegreesPerHash) {
+                hashes.add(encodeHashToLong(lat, lon, length));
             }
         }
         // ensure have the borders covered
         for (double lat = bottomRightLat; lat <= topLeftLat; lat += actualHeightDegreesPerHash) {
-            hashes.add(encodeHashToLong(lat, to180(bottomRightLon), length));
+            hashes.add(encodeHashToLong(lat, maxLon, length));
         }
-        for (double lon = topLeftLon; lon <= bottomRightLon; lon += actualWidthDegreesPerHash) {
-            hashes.add(encodeHashToLong(topLeftLat, to180(lon), length));
+        for (double lon = topLeftLon; lon <= maxLon; lon += actualWidthDegreesPerHash) {
+            hashes.add(encodeHashToLong(topLeftLat, lon, length));
         }
         // ensure that the topRight corner is covered
-        hashes.add(encodeHashToLong(topLeftLat, to180(bottomRightLon), length));
+        hashes.add(encodeHashToLong(topLeftLat, maxLon, length));
 
         double areaDegrees = diff * (topLeftLat - bottomRightLat);
         double coverageAreaDegrees = hashes.count * widthDegrees(length) * heightDegrees(length);
