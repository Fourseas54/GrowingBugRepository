diff --git a/tape/src/main/java/com/squareup/tape/QueueFile.java b/tape/src/main/java/com/squareup/tape/QueueFile.java
index 38cd00d..1fe7fd8 100644
--- a/tape/src/main/java/com/squareup/tape/QueueFile.java
+++ b/tape/src/main/java/com/squareup/tape/QueueFile.java
@@ -98,7 +98,7 @@ public final class QueueFile implements Closeable, Iterable<byte[]> {
   private Element last;
 
   /** In-memory buffer. Big enough to hold the header. */
-  private final byte[] buffer = new byte[HEADER_LENGTH];
+  private final byte[] buffer = new byte[16];
 
   /**
    * The number of times this file has been structurally modified â€” it is incremented during
@@ -112,46 +112,45 @@ public final class QueueFile implements Closeable, Iterable<byte[]> {
    * at a time.
    */
   public QueueFile(File file) throws IOException {
-    this(initializeFromFile(file));
-  }
 
-  private static RandomAccessFile initializeFromFile(File file) throws IOException {
     if (!file.exists()) {
       // Use a temp file so we don't leave a partially-initialized file.
-      File tempFile = new File(file.getPath() + ".tmp");
-      RandomAccessFile raf = open(tempFile);
-      try {
-        raf.setLength(INITIAL_LENGTH);
-        raf.seek(0);
-        raf.writeInt(INITIAL_LENGTH);
-      } finally {
-        raf.close();
-      }
+      initialize(file);
 
       // A rename is atomic.
-      if (!tempFile.renameTo(file)) {
-        throw new IOException("Rename failed!");
-      }
     }
+    raf = open(file);
+    readHeader();
+  }
 
-    return open(file);
+  QueueFile(RandomAccessFile raf) throws IOException {
+    this.raf = raf;
+    readHeader();
   }
 
   /** Opens a random access file that writes synchronously. */
-  private static RandomAccessFile open(File file) throws FileNotFoundException {
-    return new RandomAccessFile(file, "rwd");
+  private static void writeInt(byte[] buffer, int offset, int value) {
+    buffer[offset] = (byte) (value >> 24);
+    buffer[offset + 1] = (byte) (value >> 16);
+    buffer[offset + 2] = (byte) (value >> 8);
+    buffer[offset + 3] = (byte) value;
   }
 
-  QueueFile(RandomAccessFile raf) throws IOException {
-    this.raf = raf;
+  private static int readInt(byte[] buffer, int offset) {
+    return ((buffer[offset] & 0xff) << 24)
+        + ((buffer[offset + 1] & 0xff) << 16)
+        + ((buffer[offset + 2] & 0xff) << 8)
+        + (buffer[offset + 3] & 0xff);
+  }
 
+  private void readHeader() throws IOException {
     raf.seek(0);
     raf.readFully(buffer);
     fileLength = readInt(buffer, 0);
     if (fileLength > raf.length()) {
       throw new IOException(
           "File is truncated. Expected length: " + fileLength + ", Actual length: " + raf.length());
-    } else if (fileLength <= HEADER_LENGTH) {
+    } else if (fileLength <= 0) {
       throw new IOException(
           "File is corrupt; length stored in header (" + fileLength + ") is invalid.");
     }
@@ -166,20 +165,8 @@ public final class QueueFile implements Closeable, Iterable<byte[]> {
    * Stores an {@code int} in the {@code byte[]}. The behavior is equivalent to calling
    * {@link RandomAccessFile#writeInt}.
    */
-  private static void writeInt(byte[] buffer, int offset, int value) {
-    buffer[offset    ] = (byte) (value >> 24);
-    buffer[offset + 1] = (byte) (value >> 16);
-    buffer[offset + 2] = (byte) (value >> 8);
-    buffer[offset + 3] = (byte) value;
-  }
 
   /** Reads an {@code int} from the {@code byte[]}. */
-  private static int readInt(byte[] buffer, int offset) {
-    return ((buffer[offset    ] & 0xff) << 24)
-        +  ((buffer[offset + 1] & 0xff) << 16)
-        +  ((buffer[offset + 2] & 0xff) << 8)
-        +   (buffer[offset + 3] & 0xff);
-  }
 
   /**
    * Writes header atomically. The arguments contain the updated values. The class member fields
@@ -203,6 +190,25 @@ public final class QueueFile implements Closeable, Iterable<byte[]> {
     int length = readInt(buffer, 0);
     return new Element(position, length);
   }
+  private static void initialize(File file) throws IOException {
+    File tempFile = new File(file.getPath() + ".tmp");
+    RandomAccessFile raf = open(tempFile);
+    try {
+      raf.setLength(INITIAL_LENGTH);
+      raf.seek(0);
+      byte[] headerBuffer = new byte[16];
+      writeInt(headerBuffer, 0, INITIAL_LENGTH);
+      raf.write(headerBuffer);
+    } finally {
+      raf.close();
+    }
+    if (!tempFile.renameTo(file)) {
+      throw new IOException("Rename failed!");
+    }
+  }
+  private static RandomAccessFile open(File file) throws FileNotFoundException {
+    return new RandomAccessFile(file, "rwd");
+  }
 
   /** Wraps the position if it exceeds the end of the file. */
   @Private int wrapPosition(int position) {
