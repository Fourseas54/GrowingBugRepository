diff --git a/src/main/java/org/locationtech/proj4j/Registry.java b/src/main/java/org/locationtech/proj4j/Registry.java
index ab98da2..72ca361 100755
--- a/src/main/java/org/locationtech/proj4j/Registry.java
+++ b/src/main/java/org/locationtech/proj4j/Registry.java
@@ -159,7 +159,7 @@ public class Registry {
         register("bonne", BonneProjection.class, "Bonne (Werner lat_1=90)");
         register("cass", CassiniProjection.class, "Cassini");
         register("cc", CentralCylindricalProjection.class, "Central Cylindrical");
-        register("cea", CylindricalEqualAreaProjection.class, "Equal Area Cylindrical");
+        register("cea", EqualAreaCylindricalProjection.class, "Equal Area Cylindrical");
 //    register( "chamb", Projection.class, "Chamberlin Trimetric" );
         register("collg", CollignonProjection.class, "Collignon");
         register("crast", CrasterProjection.class, "Craster Parabolic (Putnins P4)");
@@ -194,10 +194,8 @@ public class Registry {
         register("lagrng", LagrangeProjection.class, "Lagrange");
         register("larr", LarriveeProjection.class, "Larrivee");
         register("lask", LaskowskiProjection.class, "Laskowski");
-        register("latlong", LongLatProjection.class, "Lat/Long (Geodetic alias)");
-        register("longlat", LongLatProjection.class, "Lat/Long (Geodetic alias)");
-        register("latlon", LongLatProjection.class, "Lat/Long (Geodetic alias)");
-        register("lonlat", LongLatProjection.class, "Lat/Long (Geodetic)");
+        register("latlong", LongLatProjection.class, "Lat/Long");
+        register("longlat", LongLatProjection.class, "Lat/Long");
         register("lcc", LambertConformalConicProjection.class, "Lambert Conformal Conic");
         register("leac", LambertEqualAreaConicProjection.class, "Lambert Equal Area Conic");
 //    register( "lee_os", Projection.class, "Lee Oblated Stereographic" );
diff --git a/src/main/java/org/locationtech/proj4j/proj/CylindricalEqualAreaProjection.java b/src/main/java/org/locationtech/proj4j/proj/CylindricalEqualAreaProjection.java
index 5108c63..62e576b 100644
--- a/src/main/java/org/locationtech/proj4j/proj/CylindricalEqualAreaProjection.java
+++ b/src/main/java/org/locationtech/proj4j/proj/CylindricalEqualAreaProjection.java
@@ -27,6 +27,7 @@ public class CylindricalEqualAreaProjection extends Projection {
 
 	private double qp;
 	private double[] apa;
+	private double trueScaleLatitude;
 
 	public CylindricalEqualAreaProjection() {
 		this(0.0, 0.0, 0.0);
diff --git a/src/main/java/org/locationtech/proj4j/proj/EqualAreaCylindricalProjection.java b/src/main/java/org/locationtech/proj4j/proj/EqualAreaCylindricalProjection.java
new file mode 100644
index 0000000..fae44dc
--- /dev/null
+++ b/src/main/java/org/locationtech/proj4j/proj/EqualAreaCylindricalProjection.java
@@ -0,0 +1,93 @@
+/*******************************************************************************
+ * Copyright 2009, 2017 Martin Davis
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.locationtech.proj4j.proj;
+
+import static java.lang.Math.abs;
+import static java.lang.Math.asin;
+import static java.lang.Math.sin;
+import static org.locationtech.proj4j.util.ProjectionMath.EPS10;
+import static org.locationtech.proj4j.util.ProjectionMath.HALFPI;
+import static org.locationtech.proj4j.util.ProjectionMath.authlat;
+import static org.locationtech.proj4j.util.ProjectionMath.authset;
+import static org.locationtech.proj4j.util.ProjectionMath.qsfn;
+
+import org.locationtech.proj4j.ProjCoordinate;
+import org.locationtech.proj4j.ProjectionException;
+
+/**
+ * The Equal Area Cylindrical projection.
+ */
+public class EqualAreaCylindricalProjection extends Projection {
+
+    double apa[];
+    double qp;
+
+	public EqualAreaCylindricalProjection() {
+		minLatitude = Math.toRadians(-60);
+		maxLatitude = Math.toRadians(60);
+		minLongitude = Math.toRadians(-90);
+		maxLongitude = Math.toRadians(90);
+		initialize();
+	}
+	
+    @Override
+	public ProjCoordinate project(double lplam, double lpphi, ProjCoordinate out) {
+        if (es != 0) {
+            // e_forward
+            out.x = scaleFactor * lplam;
+            out.y = 0.5 * qsfn(sin(lpphi), e, one_es) / scaleFactor;
+        } else {
+            // s_forward
+            out.x = scaleFactor * lplam;
+            out.y = sin(lpphi) / scaleFactor;
+        }
+        return out;
+    }
+
+    @Override
+    protected ProjCoordinate projectInverse(double x, double y, ProjCoordinate dst) {
+        if (es != 0) {
+            // e_inverse
+            dst.x = authlat(asin(2d * y * scaleFactor / qp), apa);
+            dst.y = x / scaleFactor;
+        } else {
+            // s_inverse
+            double t;
+
+            if ((t = abs(y *= scaleFactor)) - EPS10 <= 1.) {
+                if (t >= 1.)
+                    dst.x = y < 0. ? -HALFPI : HALFPI;
+                else
+                    dst.x = asin(y);
+                dst.y = x / scaleFactor;
+            } else throw new ProjectionException();
+        }
+        return dst;
+    }
+
+    @Override
+    public void initialize() {
+        super.initialize();
+        if (es != 0) {
+            apa = authset(es);
+            qp = qsfn(1., e, one_es);
+        }
+    }
+
+	public String toString() {
+		return "Equal Area Cylindrical";
+	}
+}
