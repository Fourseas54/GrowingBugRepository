diff --git a/src/test/java/org/locationtech/proj4j/proj/ProjectionEqualityTest.java b/src/test/java/org/locationtech/proj4j/proj/ProjectionEqualityTest.java
deleted file mode 100644
index 9860373..0000000
--- a/src/test/java/org/locationtech/proj4j/proj/ProjectionEqualityTest.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*******************************************************************************
- * Copyright 2019 Azavea
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package org.locationtech.proj4j.proj;
-
-import org.locationtech.proj4j.CRSFactory;
-import org.locationtech.proj4j.CoordinateReferenceSystem;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-
-import org.junit.Test;
-
-/**
- * Tests that Projection equality is semantically correct
- */
-public class ProjectionEqualityTest
-{
-	private static CRSFactory csFactory = new CRSFactory();
-
-	@Test
-	public void utmEquality() {
-
-    CoordinateReferenceSystem cs1 = csFactory.createFromName("EPSG:26710");
-    CoordinateReferenceSystem cs2 = csFactory.createFromParameters(null, "+proj=utm +zone=10 +datum=NAD27 +units=m +no_defs");
-    assertEquals(cs1, cs2);
-
-    CoordinateReferenceSystem cs3 = csFactory.createFromName("EPSG:26711");
-    assertNotEquals(cs1, cs3);
-  }
-}
diff --git a/src/test/java/org/locationtech/proj4j/proj/ProjectionGridRoundTripper.java b/src/test/java/org/locationtech/proj4j/proj/ProjectionGridRoundTripper.java
index 773799c..faaa96b 100644
--- a/src/test/java/org/locationtech/proj4j/proj/ProjectionGridRoundTripper.java
+++ b/src/test/java/org/locationtech/proj4j/proj/ProjectionGridRoundTripper.java
@@ -23,7 +23,7 @@ import org.locationtech.proj4j.ProjCoordinate;
 import org.locationtech.proj4j.proj.Projection;
 import org.locationtech.proj4j.util.ProjectionUtil;
 
-public class ProjectionGridRoundTripper
+public class ProjectionGridRoundTripper 
 {
 	private static final CoordinateTransformFactory ctFactory = new CoordinateTransformFactory();
   CRSFactory csFactory = new CRSFactory();
@@ -38,36 +38,38 @@ public class ProjectionGridRoundTripper
 	private boolean debug = false;
 	private int transformCount = 0;
 	private double[] gridExtent;
-
+	
 	public ProjectionGridRoundTripper(CoordinateReferenceSystem cs)
 	{
 		this.cs = cs;
-    transInverse = ctFactory.createTransform(cs, WGS84);
-    transForward = ctFactory.createTransform(WGS84, cs);
+    transInverse = ctFactory.createTransform(cs, WGS84); 
+    transForward = ctFactory.createTransform(WGS84, cs); 
 	}
-
+	
 	public void setLevelDebug(boolean debug)
 	{
 		this.debug = debug;
 	}
-
+	
 	public int getTransformCount()
 	{
 		return transformCount;
 	}
-
+	
 	public double[] getExtent()
 	{
 		return gridExtent;
 	}
 	public boolean runGrid(double tolerance)
 	{
+		boolean isWithinTolerance = true;
+		
 		gridExtent = gridExtent(cs.getProjection());
 		double minx = gridExtent[0];
 		double miny = gridExtent[1];
 		double maxx = gridExtent[2];
 		double maxy = gridExtent[3];
-
+		
     ProjCoordinate p = new ProjCoordinate();
 		double dx = (maxx - minx) / gridSize;
 		double dy = (maxy - miny) / gridSize;
@@ -80,7 +82,7 @@ public class ProjectionGridRoundTripper
 				 p.y = iy == gridSize ?
 						 	maxy
 					 		: miny + iy * dy;
-
+					 		
 				 boolean isWithinTol = roundTrip(p, tolerance);
 				 if (! isWithinTol)
 					 return false;
@@ -88,50 +90,50 @@ public class ProjectionGridRoundTripper
 		}
 		return true;
 	}
-
+	
   ProjCoordinate p2 = new ProjCoordinate();
   ProjCoordinate p3 = new ProjCoordinate();
 
 	private boolean roundTrip(ProjCoordinate p, double tolerance)
 	{
 		transformCount++;
-
+		
     transForward.transform(p, p2);
     transInverse.transform(p2, p3);
-
-		if (debug)
+		
+		if (debug) 
 			System.out.println(ProjectionUtil.toString(p) + " -> " + ProjectionUtil.toString(p2) + " ->  " + ProjectionUtil.toString(p3));
-
+		
 		double dx = Math.abs(p3.x - p.x);
 		double dy = Math.abs(p3.y - p.y);
-
+		
     boolean isInTol = dx <= tolerance && dy <= tolerance;
-
-    if (! isInTol)
+    
+    if (! isInTol) 
       System.out.println("FAIL: " + ProjectionUtil.toString(p) + " -> " + ProjectionUtil.toString(p2) + " ->  " + ProjectionUtil.toString(p3));
 
-
+    
 		return isInTol;
 	}
-
+	
 	public static double[] gridExtent(Projection proj)
 	{
 		// scan all lat/lon params to try and determine a reasonable extent
-
+		
 		double lon = proj.getProjectionLongitudeDegrees();
-
+		
 		double[] latExtent = new double[] {Double.MAX_VALUE, Double.MIN_VALUE };
 		updateLat(proj.getProjectionLatitudeDegrees(), latExtent);
 		updateLat(proj.getProjectionLatitude1Degrees(), latExtent);
 		updateLat(proj.getProjectionLatitude2Degrees(), latExtent);
-
+			
 		double centrex = lon;
 		double centrey = 0.0;
 		double gridWidth = 10;
-
+		
 		if (latExtent[0] < Double.MAX_VALUE && latExtent[1] > Double.MIN_VALUE) {
 			// got a good candidate
-
+			
 			double dlat = latExtent[1] - latExtent[0];
 			if (dlat > 0) gridWidth = 2 * dlat;
 		  centrey = (latExtent[1] + latExtent[0]) /2;
@@ -143,7 +145,7 @@ public class ProjectionGridRoundTripper
 		extent[3] = centrey + gridWidth/2;
 		return extent;
 	}
-
+	
 	private static void updateLat(double lat, double[] latExtent)
 	{
 		// 0.0 indicates not set (for most projections?)
