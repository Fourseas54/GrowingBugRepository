diff --git a/java/src/main/java/com/google/openlocationcode/OpenLocationCode.java b/java/src/main/java/com/google/openlocationcode/OpenLocationCode.java
index ecd5067..bfe386c 100644
--- a/java/src/main/java/com/google/openlocationcode/OpenLocationCode.java
+++ b/java/src/main/java/com/google/openlocationcode/OpenLocationCode.java
@@ -14,6 +14,8 @@
 
 package com.google.openlocationcode;
 
+import java.math.BigDecimal;
+import java.math.RoundingMode;
 import java.util.Objects;
 
 /**
@@ -61,39 +63,34 @@ public final class OpenLocationCode {
   public static final int MAX_DIGIT_COUNT = 15;
 
   // Maximum code length using just lat/lng pair encoding.
-  private static final int PAIR_CODE_LENGTH = 10;
 
   // Number of digits in the grid coding section.
-  private static final int GRID_CODE_LENGTH = MAX_DIGIT_COUNT - PAIR_CODE_LENGTH;
 
   // The base to use to convert numbers to/from.
-  private static final int ENCODING_BASE = CODE_ALPHABET.length();
+  private static final BigDecimal ENCODING_BASE = new BigDecimal(CODE_ALPHABET.length());
 
   // The maximum value for latitude in degrees.
-  private static final long LATITUDE_MAX = 90;
+  private static final BigDecimal LATITUDE_MAX = new BigDecimal(90);
 
   // The maximum value for longitude in degrees.
-  private static final long LONGITUDE_MAX = 180;
+  private static final BigDecimal LONGITUDE_MAX = new BigDecimal(180);
+  private static final int PAIR_CODE_LENGTH = 10;
 
   // Number of columns in the grid refinement method.
-  private static final int GRID_COLUMNS = 4;
+  private static final BigDecimal GRID_COLUMNS = new BigDecimal(4);
 
   // Number of rows in the grid refinement method.
-  private static final int GRID_ROWS = 5;
+  private static final BigDecimal GRID_ROWS = new BigDecimal(5);
 
   // Value to multiple latitude degrees to convert it to an integer with the maximum encoding
   // precision. I.e. ENCODING_BASE**3 * GRID_ROWS**GRID_CODE_LENGTH
-  private static final long LAT_INTEGER_MULTIPLIER = 8000 * 3125;
 
   // Value to multiple longitude degrees to convert it to an integer with the maximum encoding
   // precision. I.e. ENCODING_BASE**3 * GRID_COLUMNS**GRID_CODE_LENGTH
-  private static final long LNG_INTEGER_MULTIPLIER = 8000 * 1024;
 
   // Value of the most significant latitude digit after it has been converted to an integer.
-  private static final long LAT_MSP_VALUE = LAT_INTEGER_MULTIPLIER * ENCODING_BASE * ENCODING_BASE;
 
   // Value of the most significant longitude digit after it has been converted to an integer.
-  private static final long LNG_MSP_VALUE = LNG_INTEGER_MULTIPLIER * ENCODING_BASE * ENCODING_BASE;
 
   /**
    * Coordinates of a decoded Open Location Code.
@@ -103,17 +100,17 @@ public final class OpenLocationCode {
    */
   public static class CodeArea {
 
-    private final double southLatitude;
-    private final double westLongitude;
-    private final double northLatitude;
-    private final double eastLongitude;
+    private final BigDecimal southLatitude;
+    private final BigDecimal westLongitude;
+    private final BigDecimal northLatitude;
+    private final BigDecimal eastLongitude;
     private final int length;
 
     public CodeArea(
-        double southLatitude,
-        double westLongitude,
-        double northLatitude,
-        double eastLongitude,
+        BigDecimal southLatitude,
+        BigDecimal westLongitude,
+        BigDecimal northLatitude,
+        BigDecimal eastLongitude,
         int length) {
       this.southLatitude = southLatitude;
       this.westLongitude = westLongitude;
@@ -123,35 +120,35 @@ public final class OpenLocationCode {
     }
 
     public double getSouthLatitude() {
-      return southLatitude;
+      return southLatitude.doubleValue();
     }
 
     public double getWestLongitude() {
-      return westLongitude;
+      return westLongitude.doubleValue();
     }
 
     public double getLatitudeHeight() {
-      return northLatitude - southLatitude;
+      return northLatitude.subtract(southLatitude).doubleValue();
     }
 
     public double getLongitudeWidth() {
-      return eastLongitude - westLongitude;
+      return eastLongitude.subtract(westLongitude).doubleValue();
     }
 
     public double getCenterLatitude() {
-      return (southLatitude + northLatitude) / 2;
+      return southLatitude.add(northLatitude).doubleValue() / 2;
     }
 
     public double getCenterLongitude() {
-      return (westLongitude + eastLongitude) / 2;
+      return westLongitude.add(eastLongitude).doubleValue() / 2;
     }
 
     public double getNorthLatitude() {
-      return northLatitude;
+      return northLatitude.doubleValue();
     }
 
     public double getEastLongitude() {
-      return eastLongitude;
+      return eastLongitude.doubleValue();
     }
 
     public int getLength() {
@@ -188,7 +185,7 @@ public final class OpenLocationCode {
     // Limit the maximum number of digits in the code.
     codeLength = Math.min(codeLength, MAX_DIGIT_COUNT);
     // Check that the code length requested is valid.
-    if (codeLength < PAIR_CODE_LENGTH && codeLength % 2 == 1 || codeLength < 4) {
+    if (codeLength < 4 || (codeLength < PAIR_CODE_LENGTH && codeLength % 2 == 1)) {
       throw new IllegalArgumentException("Illegal code length " + codeLength);
     }
     // Ensure that latitude and longitude are valid.
@@ -196,12 +193,13 @@ public final class OpenLocationCode {
     longitude = normalizeLongitude(longitude);
 
     // Latitude 90 needs to be adjusted to be just less, so the returned code can also be decoded.
-    if (latitude == LATITUDE_MAX) {
+    if (latitude == LATITUDE_MAX.doubleValue()) {
       latitude = latitude - 0.9 * computeLatitudePrecision(codeLength);
     }
 
     // Store the code - we build it in reverse and reorder it afterwards.
-    StringBuilder revCodeBuilder = new StringBuilder();
+    BigDecimal remainingLatitude = new BigDecimal(latitude).add(LATITUDE_MAX);
+    BigDecimal remainingLongitude = new BigDecimal(longitude).add(LONGITUDE_MAX);
 
     // Compute the code.
     // This approach converts each value to an integer after multiplying it by
@@ -210,47 +208,51 @@ public final class OpenLocationCode {
 
     // Multiply values by their precision and convert to positive. Rounding
     // avoids/minimises errors due to floating point precision.
-    long latVal =
-        (long) (Math.round((latitude + LATITUDE_MAX) * LAT_INTEGER_MULTIPLIER * 1e6) / 1e6);
-    long lngVal =
-        (long) (Math.round((longitude + LONGITUDE_MAX) * LNG_INTEGER_MULTIPLIER * 1e6) / 1e6);
+    int generatedDigits = 0;
+    StringBuilder codeBuilder = new StringBuilder();
+    BigDecimal latPrecision = ENCODING_BASE.multiply(ENCODING_BASE);
+    BigDecimal lngPrecision = ENCODING_BASE.multiply(ENCODING_BASE);
 
     // Compute the grid part of the code if necessary.
-    if (codeLength > PAIR_CODE_LENGTH) {
-      for (int i = 0; i < GRID_CODE_LENGTH; i++) {
-        long latDigit = latVal % GRID_ROWS;
-        long lngDigit = lngVal % GRID_COLUMNS;
-        int ndx = (int) (latDigit * GRID_COLUMNS + lngDigit);
-        revCodeBuilder.append(CODE_ALPHABET.charAt(ndx));
-        latVal /= GRID_ROWS;
-        lngVal /= GRID_COLUMNS;
+    while (generatedDigits < codeLength) {
+      if (generatedDigits < PAIR_CODE_LENGTH) {
+        latPrecision = latPrecision.divide(ENCODING_BASE);
+        lngPrecision = lngPrecision.divide(ENCODING_BASE);
+        BigDecimal latDigit = remainingLatitude.divide(latPrecision, 0, RoundingMode.FLOOR);
+        BigDecimal lngDigit = remainingLongitude.divide(lngPrecision, 0, RoundingMode.FLOOR);
+        remainingLatitude = remainingLatitude.subtract(latPrecision.multiply(latDigit));
+        remainingLongitude = remainingLongitude.subtract(lngPrecision.multiply(lngDigit));
+        codeBuilder.append(CODE_ALPHABET.charAt(latDigit.intValue()));
+        codeBuilder.append(CODE_ALPHABET.charAt(lngDigit.intValue()));
+        generatedDigits += 2;
+      } else {
+        latPrecision = latPrecision.divide(GRID_ROWS);
+        lngPrecision = lngPrecision.divide(GRID_COLUMNS);
+        BigDecimal row = remainingLatitude.divide(latPrecision, 0, RoundingMode.FLOOR);
+        BigDecimal col = remainingLongitude.divide(lngPrecision, 0, RoundingMode.FLOOR);
+        remainingLatitude = remainingLatitude.subtract(latPrecision.multiply(row));
+        remainingLongitude = remainingLongitude.subtract(lngPrecision.multiply(col));
+        codeBuilder.append(
+            CODE_ALPHABET.charAt(row.intValue() * GRID_COLUMNS.intValue() + col.intValue()));
+        generatedDigits += 1;
       }
-    } else {
-      latVal /= Math.pow(GRID_ROWS, GRID_CODE_LENGTH);
-      lngVal /= Math.pow(GRID_COLUMNS, GRID_CODE_LENGTH);
-    }
     // Compute the pair section of the code.
-    for (int i = 0; i < PAIR_CODE_LENGTH / 2; i++) {
-      revCodeBuilder.append(CODE_ALPHABET.charAt((int) (lngVal % ENCODING_BASE)));
-      revCodeBuilder.append(CODE_ALPHABET.charAt((int) (latVal % ENCODING_BASE)));
-      latVal /= ENCODING_BASE;
-      lngVal /= ENCODING_BASE;
       // If we are at the separator position, add the separator.
-      if (i == 0) {
-        revCodeBuilder.append(SEPARATOR);
+      if (generatedDigits == SEPARATOR_POSITION) {
+        codeBuilder.append(SEPARATOR);
       }
     }
     // Reverse the code.
-    StringBuilder codeBuilder = revCodeBuilder.reverse();
 
     // If we need to pad the code, replace some of the digits.
-    if (codeLength < SEPARATOR_POSITION) {
-      for (int i = codeLength; i < SEPARATOR_POSITION; i++) {
-        codeBuilder.setCharAt(i, PADDING_CHARACTER);
+    if (generatedDigits < SEPARATOR_POSITION) {
+      for (; generatedDigits < SEPARATOR_POSITION; generatedDigits++) {
+        codeBuilder.append(PADDING_CHARACTER);
       }
+      codeBuilder.append(SEPARATOR);
     }
     this.code =
-        codeBuilder.subSequence(0, Math.max(SEPARATOR_POSITION + 1, codeLength + 1)).toString();
+        codeBuilder.toString();
   }
 
   /**
@@ -309,40 +311,43 @@ public final class OpenLocationCode {
           "Method decode() could only be called on valid full codes, code was " + code + ".");
     }
     // Strip padding and separator characters out of the code.
-    String clean =
+    String decoded =
         code.replace(String.valueOf(SEPARATOR), "").replace(String.valueOf(PADDING_CHARACTER), "");
 
     // Initialise the values. We work them out as integers and convert them to doubles at the end.
-    long latVal = -LATITUDE_MAX * LAT_INTEGER_MULTIPLIER;
-    long lngVal = -LONGITUDE_MAX * LNG_INTEGER_MULTIPLIER;
+    int digit = 0;
+    BigDecimal latPrecision = ENCODING_BASE.multiply(ENCODING_BASE);
+    BigDecimal lngPrecision = ENCODING_BASE.multiply(ENCODING_BASE);
     // Define the place value for the digits. We'll divide this down as we work through the code.
-    long latPlaceVal = LAT_MSP_VALUE;
-    long lngPlaceVal = LNG_MSP_VALUE;
-    for (int i = 0; i < Math.min(clean.length(), PAIR_CODE_LENGTH); i += 2) {
-      latPlaceVal /= ENCODING_BASE;
-      lngPlaceVal /= ENCODING_BASE;
-      latVal += CODE_ALPHABET.indexOf(clean.charAt(i)) * latPlaceVal;
-      lngVal += CODE_ALPHABET.indexOf(clean.charAt(i + 1)) * lngPlaceVal;
-    }
-    for (int i = PAIR_CODE_LENGTH; i < Math.min(clean.length(), MAX_DIGIT_COUNT); i++) {
-      latPlaceVal /= GRID_ROWS;
-      lngPlaceVal /= GRID_COLUMNS;
-      int digit = CODE_ALPHABET.indexOf(clean.charAt(i));
-      int row = digit / GRID_COLUMNS;
-      int col = digit % GRID_COLUMNS;
-      latVal += row * latPlaceVal;
-      lngVal += col * lngPlaceVal;
-    }
-    double latitudeLo = (double) latVal / LAT_INTEGER_MULTIPLIER;
-    double longitudeLo = (double) lngVal / LNG_INTEGER_MULTIPLIER;
-    double latitudeHi = (double) (latVal + latPlaceVal) / LAT_INTEGER_MULTIPLIER;
-    double longitudeHi = (double) (lngVal + lngPlaceVal) / LNG_INTEGER_MULTIPLIER;
+    
+    BigDecimal southLatitude = BigDecimal.ZERO;
+    BigDecimal westLongitude = BigDecimal.ZERO;
+    while (digit < Math.min(decoded.length(), MAX_DIGIT_COUNT)) {
+      if (digit < PAIR_CODE_LENGTH) {
+        latPrecision = latPrecision.divide(ENCODING_BASE);
+        lngPrecision = lngPrecision.divide(ENCODING_BASE);
+        int digitVal = CODE_ALPHABET.indexOf(decoded.charAt(digit));
+        southLatitude = southLatitude.add(latPrecision.multiply(new BigDecimal(digitVal)));
+        digitVal = CODE_ALPHABET.indexOf(decoded.charAt(digit + 1));
+        westLongitude = westLongitude.add(lngPrecision.multiply(new BigDecimal(digitVal)));
+        digit += 2;
+      } else {
+        int digitVal = CODE_ALPHABET.indexOf(decoded.charAt(digit));
+        int row = (int) (digitVal / GRID_COLUMNS.intValue());
+        int col = digitVal % GRID_COLUMNS.intValue();
+        latPrecision = latPrecision.divide(GRID_ROWS);
+        lngPrecision = lngPrecision.divide(GRID_COLUMNS);
+        southLatitude = southLatitude.add(latPrecision.multiply(new BigDecimal(row)));
+        westLongitude = westLongitude.add(lngPrecision.multiply(new BigDecimal(col)));
+        digit += 1;
+      }
+    }
     return new CodeArea(
-        latitudeLo,
-        longitudeLo,
-        latitudeHi,
-        longitudeHi,
-        Math.min(clean.length(), MAX_DIGIT_COUNT));
+        southLatitude.subtract(LATITUDE_MAX),
+        westLongitude.subtract(LONGITUDE_MAX),
+        southLatitude.subtract(LATITUDE_MAX).add(latPrecision),
+        westLongitude.subtract(LONGITUDE_MAX).add(lngPrecision),
+        digit);
   }
 
   /**
@@ -471,7 +476,7 @@ public final class OpenLocationCode {
 
     int digitsToRecover = SEPARATOR_POSITION - code.indexOf(SEPARATOR);
     // The precision (height and width) of the missing prefix in degrees.
-    double prefixPrecision = Math.pow(ENCODING_BASE, 2 - (digitsToRecover / 2));
+    double prefixPrecision = Math.pow(ENCODING_BASE.intValue(), 2 - (digitsToRecover / 2));
 
     // Use the reference location to generate the prefix.
     String recoveredPrefix =
@@ -489,10 +494,10 @@ public final class OpenLocationCode {
     // Move the recovered latitude by one precision up or down if it is too far from the reference,
     // unless doing so would lead to an invalid latitude.
     double latitudeDiff = recoveredLatitude - referenceLatitude;
-    if (latitudeDiff > prefixPrecision / 2 && recoveredLatitude - prefixPrecision > -LATITUDE_MAX) {
+    if (latitudeDiff > prefixPrecision / 2 && recoveredLatitude - prefixPrecision > -LATITUDE_MAX.intValue()) {
       recoveredLatitude -= prefixPrecision;
     } else if (latitudeDiff < -prefixPrecision / 2
-        && recoveredLatitude + prefixPrecision < LATITUDE_MAX) {
+        && recoveredLatitude + prefixPrecision < LATITUDE_MAX.intValue()) {
       recoveredLatitude += prefixPrecision;
     }
 
@@ -589,16 +594,18 @@ public final class OpenLocationCode {
     // Check the characters before the separator.
     boolean paddingStarted = false;
     for (int i = 0; i < separatorPosition; i++) {
-      if (CODE_ALPHABET.indexOf(code.charAt(i)) == -1 && code.charAt(i) != PADDING_CHARACTER) {
         // Invalid character.
-        return false;
-      }
       if (paddingStarted) {
         // Once padding starts, there must not be anything but padding.
         if (code.charAt(i) != PADDING_CHARACTER) {
           return false;
         }
-      } else if (code.charAt(i) == PADDING_CHARACTER) {
+        continue;
+      }
+      if (CODE_ALPHABET.indexOf(code.charAt(i)) != -1) {
+        continue;
+      }
+      if (PADDING_CHARACTER == code.charAt(i)) {
         paddingStarted = true;
         // Short codes cannot have padding
         if (separatorPosition < SEPARATOR_POSITION) {
@@ -608,7 +615,9 @@ public final class OpenLocationCode {
         if (i != 2 && i != 4 && i != 6) {
           return false;
         }
+        continue;
       }
+      return false;
     }
 
     // Check the characters after the separator.
@@ -661,15 +670,15 @@ public final class OpenLocationCode {
   // Private static methods.
 
   private static double clipLatitude(double latitude) {
-    return Math.min(Math.max(latitude, -LATITUDE_MAX), LATITUDE_MAX);
+    return Math.min(Math.max(latitude, -LATITUDE_MAX.intValue()), LATITUDE_MAX.intValue());
   }
 
   private static double normalizeLongitude(double longitude) {
-    while (longitude < -LONGITUDE_MAX) {
-      longitude = longitude + LONGITUDE_MAX * 2;
+    while (longitude < -LONGITUDE_MAX.intValue()) {
+      longitude = longitude + LONGITUDE_MAX.intValue() * 2;
     }
-    while (longitude >= LONGITUDE_MAX) {
-      longitude = longitude - LONGITUDE_MAX * 2;
+    while (longitude >= LONGITUDE_MAX.intValue()) {
+      longitude = longitude - LONGITUDE_MAX.intValue() * 2;
     }
     return longitude;
   }
@@ -681,8 +690,8 @@ public final class OpenLocationCode {
    */
   private static double computeLatitudePrecision(int codeLength) {
     if (codeLength <= CODE_PRECISION_NORMAL) {
-      return Math.pow(ENCODING_BASE, Math.floor(codeLength / -2 + 2));
+      return Math.pow(ENCODING_BASE.intValue(), Math.floor(codeLength / -2 + 2));
     }
-    return Math.pow(ENCODING_BASE, -3) / Math.pow(GRID_ROWS, codeLength - PAIR_CODE_LENGTH);
+    return Math.pow(ENCODING_BASE.intValue(), -3) / Math.pow(GRID_ROWS.intValue(), codeLength - PAIR_CODE_LENGTH);
   }
 }
