diff --git a/core/src/main/java/dagger/ObjectGraph.java b/core/src/main/java/dagger/ObjectGraph.java
index 1d77816a..62a03315 100644
--- a/core/src/main/java/dagger/ObjectGraph.java
+++ b/core/src/main/java/dagger/ObjectGraph.java
@@ -163,40 +163,21 @@ public abstract class ObjectGraph {
 
       // Extract bindings in the 'base' and 'overrides' set. Within each set no
       // duplicates are permitted.
-      UniqueMap<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>() {
-        @Override public Binding<?> put(String key, Binding<?> value) {
-          return super.put(key, (value instanceof SetBinding)
-              ? new SetBinding<Object>((SetBinding<Object>) value) : value);
-        }
-      };
-      if (base != null) {
-        baseBindings.putAll(base.linkEverything()); // Add parent bindings
-      }
-      UniqueMap<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>() {
-        @Override public Binding<?> put(String key, Binding<?> value) {
-          if (value instanceof SetBinding) {
-            throw new IllegalArgumentException("Module overrides cannot contribute set bindings.");
-          }
-          return super.put(key, value);
-        }
-      };
+      Map<String, Binding<?>> baseBindings = new UniqueMap<String, Binding<?>>();
+      Map<String, Binding<?>> overrideBindings = new UniqueMap<String, Binding<?>>();
       for (ModuleAdapter<?> moduleAdapter : getAllModuleAdapters(plugin, modules).values()) {
-        for (int i = 0; i < moduleAdapter.injectableTypes.length; i++) {
-          injectableTypes.put(moduleAdapter.injectableTypes[i], moduleAdapter.getModuleClass());
-        }
-        for (int i = 0; i < moduleAdapter.staticInjections.length; i++) {
-          staticInjections.put(moduleAdapter.staticInjections[i], null);
+        for (String key : moduleAdapter.injectableTypes) {
+          injectableTypes.put(key, moduleAdapter.getModule().getClass());
         }
-        try {
-          moduleAdapter.getBindings(moduleAdapter.overrides ? overrideBindings : baseBindings);
-        } catch (IllegalArgumentException e) {
-          throw new IllegalArgumentException(moduleAdapter.getModuleClass().getSimpleName()
-              + " is an overriding module and cannot contribute set bindings.");
+        for (Class<?> c : moduleAdapter.staticInjections) {
+          staticInjections.put(c, null);
         }
+        Map<String, Binding<?>> addTo = moduleAdapter.overrides ? overrideBindings : baseBindings;
+        moduleAdapter.getBindings(addTo);
       }
 
       // Create a linker and install all of the user's bindings
-      Linker linker = new Linker(plugin, new ThrowingErrorHandler());
+      Linker linker = new Linker((base != null) ? base.linker : null, plugin, new ThrowingErrorHandler());
       linker.installBindings(baseBindings);
       linker.installBindings(overrideBindings);
 
@@ -204,6 +185,7 @@ public abstract class ObjectGraph {
     }
 
     @Override public ObjectGraph plus(Object... modules) {
+      linkEverything();
       return makeGraph(this, plugin, modules);
     }
 
diff --git a/core/src/main/java/dagger/internal/Linker.java b/core/src/main/java/dagger/internal/Linker.java
index 0fef0fe4..c3a4e1e6 100644
--- a/core/src/main/java/dagger/internal/Linker.java
+++ b/core/src/main/java/dagger/internal/Linker.java
@@ -30,6 +30,7 @@ import java.util.Set;
 public final class Linker {
   private static final Object UNINITIALIZED = new Object();
 
+  private final Linker base;
   /** Bindings requiring a call to attach(). May contain deferred bindings. */
   private final Queue<Binding<?>> toLink = new LinkedList<Binding<?>>();
 
@@ -46,10 +47,11 @@ public final class Linker {
 
   private final ErrorHandler errorHandler;
 
-  public Linker(Loader plugin, ErrorHandler errorHandler) {
+  public Linker(Linker base, Loader plugin, ErrorHandler errorHandler) {
     if (plugin == null) throw new NullPointerException("plugin");
     if (errorHandler == null) throw new NullPointerException("errorHandler");
 
+    this.base = base;
     this.plugin = plugin;
     this.errorHandler = errorHandler;
   }
@@ -226,7 +228,14 @@ public final class Linker {
       boolean mustHaveInjections, boolean library) {
     assertLockHeld();
 
-    Binding<?> binding = bindings.get(key);
+    Binding<?> binding = null;
+    for (Linker linker = this; linker != null; linker = linker.base) {
+      binding = linker.bindings.get(key);
+      if (binding != null) {
+        if (linker != this && !binding.isLinked()) throw new AssertionError();
+        break;
+      }
+    }
     if (binding == null) {
       // We can't satisfy this binding. Make sure it'll work next time!
       Binding<?> deferredBinding =
@@ -264,9 +273,10 @@ public final class Linker {
    * Returns a scoped binding for {@code binding}.
    */
   static <T> Binding<T> scope(final Binding<T> binding) {
-    if (!binding.isSingleton() || binding instanceof SingletonBinding) {
+    if (!binding.isSingleton()) {
       return binding; // Default scoped binding or already a scoped binding.
     }
+    if (binding instanceof SingletonBinding) throw new AssertionError();
     return new SingletonBinding<T>(binding);
   }
 
diff --git a/core/src/main/java/dagger/internal/ModuleAdapter.java b/core/src/main/java/dagger/internal/ModuleAdapter.java
index 818ec00c..ab255ce2 100644
--- a/core/src/main/java/dagger/internal/ModuleAdapter.java
+++ b/core/src/main/java/dagger/internal/ModuleAdapter.java
@@ -57,7 +57,7 @@ public abstract class ModuleAdapter<T> {
     throw new UnsupportedOperationException("No no-args constructor on " + getClass().getName());
   }
 
-  public Class<?> getModuleClass() {
-    return module.getClass();
+  public T getModule() {
+    return module;
   }
 }
diff --git a/core/src/main/java/dagger/internal/Modules.java b/core/src/main/java/dagger/internal/Modules.java
index 36bde755..ef994cd3 100644
--- a/core/src/main/java/dagger/internal/Modules.java
+++ b/core/src/main/java/dagger/internal/Modules.java
@@ -50,7 +50,7 @@ public final class Modules {
     // Add the adapters that we have module instances for. This way we won't
     // construct module objects when we have a user-supplied instance.
     for (ModuleAdapter<?> adapter : seedAdapters) {
-      adaptersByModuleType.put(adapter.getModuleClass(), adapter);
+      adaptersByModuleType.put(adapter.getModule().getClass(), adapter);
     }
 
     // Next add adapters for the modules that we need to construct. This creates
diff --git a/core/src/main/java/dagger/internal/SetBinding.java b/core/src/main/java/dagger/internal/SetBinding.java
index 202fa5be..e49bb1c9 100644
--- a/core/src/main/java/dagger/internal/SetBinding.java
+++ b/core/src/main/java/dagger/internal/SetBinding.java
@@ -28,24 +28,21 @@ import java.util.Set;
  */
 public final class SetBinding<T> extends Binding<Set<T>> {
 
-  public static <T> void add(Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
-    prepareSetBinding(bindings, setKey, binding).contributors.add(Linker.scope(binding));
-  }
 
   @SuppressWarnings("unchecked")
-  private static <T> SetBinding<T> prepareSetBinding(
+  public static <T> void add(
       Map<String, Binding<?>> bindings, String setKey, Binding<?> binding) {
     Binding<?> previous = bindings.get(setKey);
     SetBinding<T> setBinding;
     if (previous instanceof SetBinding) {
-      return (SetBinding<T>) previous;
+      setBinding = (SetBinding) previous;
     } else if (previous != null) {
       throw new IllegalArgumentException("Duplicate:\n    " + previous + "\n    " + binding);
     } else {
       setBinding = new SetBinding<T>(setKey, binding.requiredBy);
       bindings.put(setKey, setBinding);
-      return (SetBinding<T>) bindings.get(setKey); // BindingMap.put() copies SetBindings.
     }
+    setBinding.contributors.add(Linker.scope(binding));
   }
 
   private final Set<Binding<?>> contributors = new LinkedHashSet<Binding<?>>();
